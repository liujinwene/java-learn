# 目录
1.架构演进    
2.组件    
3.其他  
4.一些个人总结  
4.1.即使是高并发系统，也是得遵循基础知识的  
5.项目经历  
6.一些技术  
6.1.java的concurrent包  
6.2.java虚拟机    
6.3.有道云笔记分享  
6.4.百度网盘分享  

# 1.架构演进
​参考: <https://www.jianshu.com/p/cf93645f4954>  
​**单一应用架构​**: 单服务器应用，比如最初的电商系统。  
​**​垂直应用架构​**: 简单地拆分模块，比如园区，支付，电商系统。  
​​**分布式服务架构​**: 更细化地拆分模块，比如电商的订单、商品模块。但没做模块统一管理。模块之间通信可以用Dubbo。  
​​**流动计算架构​**: 做了模块统一管理。比如部署了5个订单模块，5个商品模块。使用ZooKeeper做注册中心，管理所有的模块。  

# 2.组件
​**Redis​**: 缓存。另外Redis自带的PUB/SUB机制，即发布-订阅模式，可以用来做消息组件。  
**Dubbo**: RPC组件，用于微服务模块之间通信。比如电商的订单模块、商品模块之间的通信。  
**ZooKeeper**: 注册中心。管理所有微服务模块。比如服务器集群上，部署了5个订单模块，5个商品模块。商品请求订单模块接口时，先通过ZooKeeper，由ZooKeeper返回请求部署的5个订单模块的哪一个。  
**Netty**: 通信组件。比如HTTP,SOCKET,TCP,UDP等通信协议。可以使用Netty组件快速、简单实现。  

# 3.其他

	a.同步、并发、串行、并行的区别: 串行、并行是针对执行指令说的，比如说有2个CPU，可以说在同一时间，可并行执行2条指令。反之，只有1个CPU，同一时间，只能执行1条指令。（不考虑1个CPU中使用了流水线的概念）  
	b.CPU流水线概念。CPU最小执行单元，为1条指令。理论上1条指令执行完，CPU才能执行下一条指令。但是，CPU执行一条指令，内部也可分为不同阶段。比如: 取指令 -> 分析指令 -> 执行指令。这样，第1条指令进入分析指令阶段后，第2条指令就可以进入取指令阶段。  

# 4.一些个人总结
## 4.1.即使是高并发系统，也是得遵循基础知识的
a.接口的粒度尽可能小 

	一方面是尽量让接口做最少的事。比如查询商品列表接口，就是查询商品基础信息，不要轻易把秒杀商品、优惠活动商品的处理逻辑，都加在查询商品列表接口上。其他与商品关联的功能是否可以加，要权衡是否会使接口变得臃肿。  
	一方面是接口同步的代码段，逻辑尽量简单，也就是粒度尽量小。比如生成订单接口，前面先把订单、订单明细、订单优惠券等对象填充好，最后在锁、事务中，只执行insert 这些数据到数据库中，insert失败则释放锁，回滚事务。  
b.按需拆分模块  

	b1.比如整个电商系统中，按照目前阶段，只有生成订单要求高并发量。则单独将生成订单拆分为一个微服务模块。  
	b2.这样做的好处，一来其他功能，因为并发量不高，让它们共享同个服务器资源就行，节约服务器资源。  
	b3.生成订单模块，为了高并发，单独部署一台服务器，不够的话，还可以部署多台，以满足高并发要求。  
c.拆分模块后需要考虑的事  

	c1.分布式锁。目前了解的就是用redis    
	c2.模块内事务: 与单应用系统事务一样。  
	c3.跨模块事务  
		比如生成订单，肯定得扣减商品库存，并且得保证数据一致性。但他们又不在同一个系统，怎办？  
		用数据最终一致性。
		第1步:先在订单系统保存扣减库存的数据。字段有(id,orderNo,requestData,status)
		第2步:第1步成功，再远程请求扣减商品库存。商品模块用订单编号做去重校验。
		第3步:如果第2步失败，则生成订单接口可以再次执行第2步，或者返回生成订单失败结果。  
			然后有定时任务，处理第1步中，status=请求第2步失败的记录。读取此数据，请求远程恢复库存接口。以orderNo去重。  
		第4步:如果第2步成功，更新第1步status=扣库存成功。  
			再执行模块内事务处理:insert订单数据的，insert有关订单数据的记录(以便后续流程失败回滚)。  
		第5步:后续操作
d.总结

	根据a,b,c要点描述的内容，其实高并发系统，所用到的基础知识和单一系统一样。  比如:  
	都强调逻辑的完整性。比如单一系统下，生成订单，我们可以把所有更新数据的操作，放在一个事务中处理。如果执行中失败，程序自动回滚整个事务。
	但在微服务系统中，我们要考虑跨模块事务（分布式事务）。跨模块事务和单一事务的区别，就是分了步骤，单一事务的执行，我们可以理解为只有1个步骤。
	而跨模块事务要额外处理的问题，就是如何处理步骤之间的关系，保证所有步骤的完整性。  
e.面试中遇到的两个问题

	e1.如何实现分布式事务？
		方法可参考《c.拆分模块后需要考虑的事》。其中涉及到消息组件，常用的消息组件有:ActiveMQ、RabbitMQ、RocketMQ等。
	e2.被面试官问到使用过的框架，底层和细节是怎么实现的？
		面试官说: 通过了解面试者对所使用过的框架的理解深度，判断面试者的能力。
		本人的理解: 技术的学习，分为广度和深度。个人能力的成长，可以以广度为主，深度为辅。深度为辅，是因为要深入理解是一件很费时费力的事。  
			比如通过了解很多热门组件，新的设计思想，了解技术的广度。接着选择其中一个自己感兴趣的，深入研究。   

# 5.项目经历

	a.以单一应用项目为起点，说明要提高并发量，该怎么处理。  
	b.进行微服务拆分，比如在高并发下,用户量上亿、每秒请求量在5000左右。支付系统拆分为绑手机号、实名认证、绑卡、支付模块。  
	c.实名认证模块对外只提供了2个接口。查询实名结果，请求实名接口。
	d.另外因为模块拆分，必然增加了模块的复杂度。以前单一系统，只需一张表记录实名数据。拆分模块后，需要考虑把实名结果通知给其他模块。还有接收其他模块的同步信息。
	e.比如，实名认证模块，其前置流程是用户注册绑手机号，后置流程是绑银行卡。
	f.而实名模块内部，需要对接多家第三方支付，要对接多家的原因，是因为每一家第三方，都存在系统不稳定、某些功能不支持、并发量无法满足需求等因素。
	g.所以实名模块要集成多家第三方支付，因为每个第三方都存在一些问题，系统不稳定、并发量不高。但实名模块又得保证高系统稳定性、高并发量。于是有了实名路由，其职责是监控第三方渠道，实名模块先请求实名路由，得到最佳的第三方渠道，再请求此渠道的实名认证接口。

# 6.一些技术
## 6.1.java的concurrent包
	a.本人在实际工作中用的多吗？  
		回答：不多。因为即使高并发的项目，做偏业务的功能实现，很少用到concurrent包。  
			更多用的是Redis、RedisMQ、Dubbo、ZooKeeper。  
	b.那concurrent包值得去学吗？
		回答：值得。因为concurrent包中的设计、原理都值得学，可以举一反三，用到实际高并发工作中。
	c.如何学习concurrent包？
		先了解核心、普遍使用的功能。以后有时间，有兴趣再深入学习。
	d.资料
		百度网盘:《JAVA并发编程实践.pdf》  
		百度网盘:《实战Java高并发程序设计_13897056.pdf》  
		我看的方式: 找感兴趣的模块看，遇到不懂的，通过自己想，理解，或者找百度，google，验证自己的想法。总结。  
## 6.2.java虚拟机  
	a.资料  
		百度网盘:《深入理解Java虚拟机-JVM高级特性与最佳实践.pdf》  
		面试中问到了Java内存模型，垃圾回收。而我没时间，也只看了这两个模块。  
## 6.3.有道云笔记分享
	http://note.youdao.com/noteshare?id=60d9b5291c883e033efc340d9f695fde
	学习过程中，很多零碎的笔记都记在这里了。
## 6.4.百度网盘分享
	链接：https://pan.baidu.com/s/1bp0MxZp 密码：t4m1